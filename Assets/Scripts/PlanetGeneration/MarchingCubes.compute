#pragma kernel March
#include "MarchingCubesTriangulation.compute"

struct Triangle
{
    float3 v1;
    float3 v2;
    float3 v3;
};

int lod_downscale, cubes_number;
float threshold;

RWBuffer<float4> cubes;
AppendStructuredBuffer<Triangle> triangles;

int coords_to_index(int x, int y, int z)
{
    int3 id = int3(x, y, z) * lod_downscale;
    return id.x * cubes_number * cubes_number + id.y * cubes_number + id.z;
}

float3 get_middle_point(float4 v1, float4 v2)
{
    return lerp(v1.xyz, v2.xyz, (threshold - v1.w) / (v2.w - v1.w));
}

[numthreads(2,2,2)]
void March(uint3 id : SV_DispatchThreadID)
{
    int maxIndex = cubes_number - lod_downscale;
    
    if (id.x >= maxIndex || id.y >= maxIndex || id.z >= maxIndex)
        return;

    float4 corners[8] = {
        cubes[coords_to_index(id.x, id.y, id.z)],
        cubes[coords_to_index(id.x + 1, id.y, id.z)],
        cubes[coords_to_index(id.x + 1, id.y, id.z + 1)],
        cubes[coords_to_index(id.x, id.y, id.z + 1)],
        cubes[coords_to_index(id.x, id.y + 1, id.z)],
        cubes[coords_to_index(id.x + 1, id.y + 1, id.z)],
        cubes[coords_to_index(id.x + 1, id.y + 1, id.z + 1)],
        cubes[coords_to_index(id.x, id.y + 1, id.z + 1)]
    };
    
    int cubeIndex = 0;

    for (int i = 0; i < 8; i++)
    {
        if (corners[i].w >= threshold)
            cubeIndex |= 1 << i;
    }

    for (int i = 0; i < 16; i += 3)
    {
        if (triangulation[cubeIndex][i] == -1)
            break;

        float4 v00 = corners[corner1_index[triangulation[cubeIndex][i]]];
        float4 v01 = corners[corner2_index[triangulation[cubeIndex][i]]];

        float4 v10 = corners[corner1_index[triangulation[cubeIndex][i + 1]]];
        float4 v11 = corners[corner2_index[triangulation[cubeIndex][i + 1]]];

        float4 v20 = corners[corner1_index[triangulation[cubeIndex][i + 2]]];
        float4 v21 = corners[corner2_index[triangulation[cubeIndex][i + 2]]];
        
        Triangle tri;
        tri.v1 = get_middle_point(v00, v01);
        tri.v2 = get_middle_point(v10, v11);
        tri.v3 = get_middle_point(v20, v21);
        
        triangles.Append(tri);
    }
}
